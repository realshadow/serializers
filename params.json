{"name":"Serializers","tagline":"PHP collection of serializers for JSON, JSONP, XML, YAML, INI","body":"# PHP collection of serializers for JSON, JSONP, XML, YAML, INI\r\nWritten for PHP 5.3 to solve a specific issue - **singularization/pluralization** of elements when transforming them from and to arrays. The difference between serializers was obvious when we passed XML files between PHP, Python and .NET. Later, more serializers were added to get a complete package.\r\n\r\nThe goal was to automatically perform singularization of arrays when serializing to XML. E.g.\r\n\r\n```php\r\narray(\r\n\t'products' => array(\r\n\t    array(\r\n\t        'brand' => 'Samsung',\r\n\t        'model' => 'Galaxy',\r\n\t        'price' => 999\r\n\t    ),\r\n\t    array(\r\n\t        'brand' => 'HTC',\r\n\t        'model' => 'One',\r\n\t        'price' => null\r\n\t    )\r\n\t)\r\n);\r\n```\r\n\r\nWhich, when serialized, would become\r\n\r\n```xml\r\n <products>\r\n  <product>\r\n   <brand>Samsung</brand>\r\n   <model>Galaxy</model>\r\n   <price>999</price>\r\n  </product>\r\n  <product>\r\n   <brand>HTC</brand>\r\n   <model>One</model>\r\n   <price xsi:nil=\"true\"></price>\r\n  </product>\r\n </products>\r\n```\r\n\r\ninstead of (this is the default behaviour)\r\n\r\n```xml\r\n <products>\r\n   <brand>Samsung</brand>\r\n   <model>Galaxy</model>\r\n   <price>999</price>\r\n </products>\r\n <products>\r\n   <brand>HTC</brand>\r\n   <model>One</model>\r\n   <price xsi:nil=\"true\"></price>\r\n </products>\r\n```\r\n\r\nSame rule applies to deserialization which, by using different serializers, would turn into into different arrays. By applying singularization the other way around, it is possible to **get back the same array** as was used for serialization.\r\n\r\n### XML Serialization\r\nSupport for\r\n\r\n* attributes, namespaces, cdata and comments\r\n* singularization of words - products => product\r\n* option to automatically add xsi:nil=true to null elements\r\n* event for manipulation of nodes\r\n\r\n```php\r\n$array = array(\r\n\tSerializers\\Encoders\\Xml::ATTRIBUTES => array(\r\n\t\t'xmlns' => 'http://cfh.sk/izmluvnik/xsell',\r\n\t\tSerializers\\Encoders\\Xml::NS => array(\r\n\t\t\tarray(\r\n\t\t\t\t'name' => 'xmlns:xsi',\r\n\t\t\t\t'content' => 'http://www.w3.org/2001/XMLSchema-instance'\r\n\t\t\t),\r\n\t\t\tarray(\r\n\t\t\t\t'name' => 'xmlns:xsd',\r\n\t\t\t\t'content' => 'http://www.w3.org/2001/XMLSchema'\r\n\t\t\t)\r\n\t\t)\r\n\t),\r\n\t'products' => array(\r\n\t    array(\r\n\t        'brand' => 'Samsung',\r\n\t        'model' => 'Galaxy',\r\n\t        'price' => 999\r\n\t    ),\r\n\t    array(\r\n\t        'brand' => 'HTC',\r\n\t        'model' => 'One',\r\n\t        'price' => null\r\n\t    )\r\n\t)\r\n);\r\n\r\n$xml = Serializers\\Encode::toXml('root', $array, array(\r\n    'singularize_words' => true,\r\n    'nil_on_null' => true\r\n));\r\n\r\nprint $xml->withHeaders();\r\n```\r\n\r\nWhich outputs\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<root xmlns=\"http://cfh.sk/izmluvnik/xsell\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\r\n <products>\r\n  <product>\r\n   <brand>Samsung</brand>\r\n   <model>Galaxy</model>\r\n   <price>999</price>\r\n  </product>\r\n  <product>\r\n   <brand>HTC</brand>\r\n   <model>One</model>\r\n   <price xsi:nil=\"true\"></price>\r\n  </product>\r\n </products>\r\n</root>\r\n```\r\n\r\n### XML Deserialization\r\nBy default every comment, attribute, namespace will be stripped from the result as well as\r\nthe root element. Every option can be turned off/on in config\r\n\r\nDeserialization is done by SimpleXML coupled with json_encode (in this case provided JSON decoder) with one\r\nsimple addition - SimpleXML object will be transformed before being encoded with json_encode (backport of\r\nJSONSerialize interface)\r\n\r\nComments are parsed separately via DOMXpath (since SimpleXML can not handle them) and are\r\nadded to a separate array with indexes poiting to their original location, with that, it should\r\nbe easy to merge comments with the main result and receive the original array.\r\n\r\nBy default, transforming elements from their singular counterpart back to plural and thus\r\nflattening the whole array is turned off and must be turned on. Its possible to both - include\r\nnew mappings for words and to exclude specific words. This works exactly as in provided XML\r\nencoder.\r\n\r\nThe whole goal of flattening is to get back **exactly** the same array as the one that was used\r\nto create provided XML.\r\n\r\n```php\r\n// using the same XML that we got in serialization\r\n$output = Serializers\\Decode::xml($xml->load(), array('singularize_words' => true));\r\n```\r\n\r\nWhich outputs **exactly the same array** as was used in the example before\r\n\r\n```php\r\nprint_r($output->toArray());\r\n```\r\n\r\n### JSON Deserialization\r\nSupport for:\r\n *  automatic parsing of Microsoft's JSON date format (e.g. `/Date(1425556377427+0100)/`)\r\n *  backport of `JSON_BIGINT_AS_STRING` available from PHP 5.4.0\r\n *  isValid method for checking validity of provided JSON string\r\n *  possible conversion from JSON to:\r\n    - PHP types (string, array, object)\r\n    - XML, YAML, INI\r\n\r\nWith overriding configuration one can change the default timeformat and timezone settings form MS date conversion, or turn it off completely.\r\n\r\nIt's possible to register an event callback to be called during escaping of BIGINT, in case said escaping is not good enough, or to turning it off completely.\r\n\r\nCallback method must accept one parameter and thats registered JSON string. Callback can be a closure or anything else that will pass as callable.\r\n\r\n```php\r\n$json = <<<EOT\r\n    {\r\n        \"foo\" : \"bar\",\r\n        \"small\" : \"123456\",\r\n        \"large\" : 200000000000009093302,\r\n        \"text\" : \"Example ratio 1000000000000000:1\",\r\n        \"date\" : \"/Date(1425556377427+0100)/\"\r\n    }\r\nEOT;\r\n\r\n$s = Serializers\\Decode::json($json);\r\n\r\nprint_r($s->toObject());\r\n\r\n// transform said json to xml and output it\r\n\r\nprint Serializers\\Decode::json($json)->toXml('root')->withHeaders();\r\n\r\n// events\r\n\r\n$json = Serializers\\Decode::json($json)->on(Serializers\\Events::JSON_MSDATE_MATCH, function($date) {\r\n    // matches returned from preg_replace_callback\r\n    list(, $timestamp,,) = $date;\r\n\r\n    return date('Y-m-d H:i:s', $timestamp);\r\n});\r\n```\r\n\r\n### JSON Serialization\r\nIt is possible to register JSON_SERIALIZE event that works exactly like PHP 5.4 `JsonSerializable` interface and thus allows modifying the object before it is converted to JSON.\r\n\r\nJSON Serializer also includes a method for creating dates in Microsoft JSON date format, e.g `/Date(1425556377427+0100)/`\r\n\r\n```php\r\n$json = Serializers\\Encode::toJson(array(\r\n    'foo' => 'bar',\r\n    'foodate' => date('d.m.Y H:i:s')\r\n))->onSerialize(function($data) {\r\n    $data['foodate'] = Serializers\\Encoders\\Json::toMSDate($data['foodate']);\r\n\r\n    return $data;\r\n});\r\n\r\nprint $json->withHeaders();\r\n```\r\n\r\n### JSONP Serialization\r\nClass for easy JSONP serialization, behaves like JSON serializer with additional checks for callback function name validation, which can be changed with custom event\r\n\r\n```php\r\n$jsonp = Serializers\\Encode::toJsonp('_foo.bar', array(\r\n    'foo' => 'bar',\r\n    'bar' => 'foo'\r\n));\r\n\r\n$jsonp->allowCors('*', array('GET', 'POST'));\r\n\r\nprint $jsonp->withHeaders();\r\n```\r\n\r\n### JSONP Deserialization\r\nClass for easy JSONP deserialization, behaves like JSON deserializer\r\n\r\n```php\r\n$json = '_foo.bar({\"foo\":\"bar\",\"bar\":\"foo\"})';\r\n\r\n$data = Serializers\\Decode::jsonp($json);\r\n\r\nprint_r($data->toObject());\r\n\r\n// transform said json to xml with callback name as root element and output it\r\n\r\nprint Serializers\\Decode::jsonp($json)->toXml()->withHeaders();\r\n```\r\n\r\n### YAML Serializer\r\nUses Symfony's YAML component under the hood\r\n\r\n```php\r\n$yaml = \\Serializers\\Encode::toYaml($array);\r\n\r\nprint_r($yaml->load());\r\n\r\n// or\r\n\r\n$yaml->toFile('config.yml');\r\n```\r\n\r\n### YAML Deserializer\r\nUses Symfony's YAML component under the hood.\r\n\r\nTransformation to `XML`, `JSON`, etc. is possible, but is subjected to the possibilities of the YAML converter.\r\n\r\n```php\r\n$yaml = Serializers\\Decode::yaml(file_get_contents('config.yml'));\r\n\r\nprint_r($yaml->toObject());\r\n\r\n// transform said json to xml and output it\r\n\r\nprint Serializers\\Decode::yaml(file_get_contents('config.yml'))->toXml('yaml')->withHeaders();\r\n```\r\n\r\n### INI Deserializer\r\nUses INI parser by @austinhyde\r\n\r\n```php\r\n$array = array(\r\n\t'a' => 'd',\r\n\t'b' => array('test' => 'c'),\r\n\t'database' => array(\r\n\t\t'default' => array(\r\n\t\t\t'name' => 'db',\r\n\t\t\t'host' => 'master.db',\r\n\t\t\t'ip' => 'dd',\r\n\t\t)\r\n\t),\r\n\t'array' => array('a', '1', 3),\r\n);\r\n\r\n$encode = Serializers\\Encode::toIni($array);\r\n$encode->toFile('config.ini');\r\n```\r\n\r\n### INI Serializer\r\nThe functionality is limited to basic INI formats, e.g. no support for inheritance. As I can't see a good use case at the moment, this class is here only for keeping a complete stack of encoders/decoders together\r\n\r\n```php\r\n$ini = Serializers\\Encode::toIni($array);\r\n\r\nprint_r($ini->load());\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}